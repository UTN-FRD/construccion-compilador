use std::str::FromStr;
use ast::{Expr, Atom};

grammar;

pub Program: Vec<Expr> = {
    Expr*
}

// If I ever move define calls into the syntactic anaylser
// these are the rules we should follow
// https://docs.racket-lang.org/guide/syntax-overview.html#%28part._local-binding-intro%29
//
// For now we are using a much simpler form
// TODO eventually we will want to dicover syntactically the following constructs
// (define (myFn ...args) body)
// (define varName varValue)
// (let ([varName varValue]+) expr)
// And probably more
//
// This will make the semantic side of the code (the eval)
// much more easy and simpler
pub Expr: Expr = {
    "(" "define" "(" <fn_name: FnName> <arg_names: ArgName*> ")" <body: Expr+> ")" => {
        Expr::DefineFunction(fn_name, arg_names, body)
    },

    "(" "define" <var_name: VarName> <var_value: Expr> ")" => {
        Expr::DefineVariable(var_name, Box::new(var_value))
    },

    "(" <l:List> ")" => Expr::List(l),
    <a:Atom> => Expr::Atom(a),
};

pub List: Vec<Expr> = {
    Expr*
}

//TODO unify the ID definition and also make it much flexible,
//it shoul accept names-like-this?
pub Atom: Atom = {
    "+" => Atom::Id("+".to_string()),
    "-" => Atom::Id("-".to_string()),
    <s:r"[A-Za-z]([0-9A-Za-z])*"> => Atom::Id(s.to_string()),
    //TODO commas
    <s:r"[0-9]+"> => Atom::Num(f64::from_str(s).unwrap()),
    //TODO strings!
}

pub FnName: String = <s:r"[A-Za-z]([0-9A-Za-z])*"> => s.to_string();
pub ArgName: String =  <s:r"[A-Za-z]([0-9A-Za-z])*"> => s.to_string();
pub VarName: String  =  <s:r"[A-Za-z]([0-9A-Za-z])*"> => s.to_string();
